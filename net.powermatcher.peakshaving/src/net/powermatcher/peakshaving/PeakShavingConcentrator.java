package net.powermatcher.peakshaving;

import java.lang.annotation.Annotation;
import java.util.Arrays;
import java.util.Map;

import javax.measure.Measurable;
import javax.measure.quantity.Power;
import javax.measure.unit.SI;

import org.osgi.service.component.annotations.Activate;
import org.osgi.service.component.annotations.Component;
import org.osgi.service.component.annotations.Deactivate;
import org.osgi.service.metatype.annotations.AttributeDefinition;
import org.osgi.service.metatype.annotations.AttributeType;
import org.osgi.service.metatype.annotations.Designate;
import org.osgi.service.metatype.annotations.ObjectClassDefinition;

import net.powermatcher.api.AgentEndpoint;
import net.powermatcher.api.MatcherEndpoint;
import net.powermatcher.api.data.Bid;
import net.powermatcher.api.data.MarketBasis;
import net.powermatcher.api.data.Price;
import net.powermatcher.api.monitoring.ObservableAgent;
import net.powermatcher.core.auctioneer.Auctioneer;
import net.powermatcher.core.concentrator.Concentrator;
import net.powermatcher.core.concentrator.SentBidInformation;
import net.powermatcher.core.concentrator.TransformingConcentrator;

/**
 * <p>
 * This class represents a {@link PeakShavingConcentrator} component where several instances can be created.
 * </p>
 *
 * <p>
 * The {@link PeakShavingConcentrator} receives {@link Bid} from the agents and forwards this in an aggregate
 * {@link Bid} up in the hierarchy to a {@link PeakShavingConcentrator} or to the {@link Auctioneer}. It will receive
 * price updates from the {@link Auctioneer} and forward them to its connected agents. TODO: add PeakShavingConcentrator
 * comment.
 *
 * @author FAN
 * @version 2.1
 */
@Component(immediate = true,
           service = { ObservableAgent.class,
                       MatcherEndpoint.class,
                       AgentEndpoint.class,
                       TransformingConcentrator.class,
                       PeakShavingConcentrator.class })
@Designate(ocd = PeakShavingConcentrator.Config.class, factory = true)
public class PeakShavingConcentrator
    extends Concentrator
    implements TransformingConcentrator {

    @ObjectClassDefinition
    public @interface Config {
        @AttributeDefinition()
        String desiredParentId() default "auctioneer";

        @AttributeDefinition(type = AttributeType.LONG,
                             description = "Mimimum time between two BidUpdates generated by the Concentratro in milliseconds")
        long minTimeBetweenBidUpdates() default 1000L;

        @AttributeDefinition()
        String agentId() default "peakshavingconcentrator";

        @AttributeDefinition(type = AttributeType.DOUBLE,
                             description = "The floor constraint in Watt",
                             required = false)
        double floor() default -50000d;

        @AttributeDefinition(type = AttributeType.DOUBLE,
                             description = "The ceiling constraint in Watt",
                             required = false)
        double ceiling() default 50000d;
    }

    /**
     * Minimum power level applied in 'peak shaving'
     */
    protected double floor = -Double.MAX_VALUE;

    /**
     * Maximum power level applied in 'peak shaving'
     */
    protected double ceiling = Double.MAX_VALUE;

    /**
     * Measured flow as reported via the peak shaving interface
     */
    protected volatile double measuredFlow = Double.NaN;

    /**
     * The allocated flow as calculated from the aggregated bidcurve
     */
    protected volatile double allocatedFlow = Double.NaN;

    /**
     * OSGi calls this method to activate a managed service.
     *
     * @param properties
     *            the configuration properties
     */
    @Override
    @Activate
    public void activate(final Map<String, ?> properties) {
        final String agentId = (String) properties.get("agentId");
        final String desiredParentId = (String) properties.get("desiredParentId");
        final long minTimeBetweenBidUpdates = ((Number) properties.get("minTimeBetweenBidUpdates")).longValue();
        final double floor = ((Number) properties.get("floor")).doubleValue();
        final double ceiling = ((Number) properties.get("ceiling")).doubleValue();

        activate(new Config() {
            @Override
            public String desiredParentId() {
                return desiredParentId;
            }

            @Override
            public long minTimeBetweenBidUpdates() {
                return minTimeBetweenBidUpdates;
            }

            @Override
            public String agentId() {
                return agentId;
            }

            @Override
            public double floor() {
                return floor;
            }

            @Override
            public double ceiling() {
                return ceiling;
            }

            @Override
            public Class<? extends Annotation> annotationType() {
                return Config.class;
            }
        });
    }

    /**
     * Convenient activate method that takes a {@link Config} object. This also makes subclassing easier.
     *
     * @param config
     *            The {@link Config} object that configures this concentrator
     */
    public void activate(final Config config) {
        floor = config.floor();
        ceiling = config.ceiling();

        if (ceiling <= floor) {
            throw new IllegalArgumentException("The floor constraint shouldn't be higher than the ceiling constraint");
        }

        measuredFlow = Double.NaN;
        super.activate(new Concentrator.Config() {
            @Override
            public Class<? extends Annotation> annotationType() {
                return Concentrator.Config.class;
            }

            @Override
            public String agentId() {
                return config.agentId();
            }

            @Override
            public String desiredParentId() {
                return config.desiredParentId();
            }

            @Override
            public long minTimeBetweenBidUpdates() {
                return config.minTimeBetweenBidUpdates();
            }
        });
    }

    /**
     * OSGi calls this method to deactivate a managed service.
     */
    @Override
    @Deactivate
    public void deactivate() {
        super.deactivate();
    }

    @Override
    protected Bid transformBid(Bid aggregatedBid) {
        Bid bid = aggregatedBid;
        double uncontrolledFlow = getUncontrolledFlow();

        if (!Double.isNaN(uncontrolledFlow)) {
            bid = bid.transpose(uncontrolledFlow);
        }
        bid = clip(bid);
        if (!Double.isNaN(uncontrolledFlow)) {
            bid = bid.transpose(-uncontrolledFlow);
        }

        return bid;
    }

    @Override
    protected Price transformPrice(Price price, SentBidInformation info) {
        // Find the transformedBid that has the same bidnumber as the bid
        Bid originalBid = info.getOriginalBid();
        Bid transformedBid = info.getSentBid();

        int priceIndex = price.getPriceIndex();
        double transformedDemand = transformedBid.getDemandAt(price);
        double realDemand = originalBid.getDemandAt(price);

        MarketBasis marketBasis = price.getMarketBasis();

        if (transformedDemand < realDemand) {
            // Increase the price step until this is no longer true
            while (transformedDemand < realDemand && priceIndex < marketBasis.getPriceSteps()) {
                priceIndex += 1;
                realDemand = originalBid.getDemandAt(Price.fromPriceIndex(marketBasis, priceIndex));
            }
        } else if (transformedDemand > realDemand) {
            // Decrease the price step until this is no longer true
            while (transformedDemand > realDemand && priceIndex >= 0) {
                priceIndex -= 1;
                realDemand = originalBid.getDemandAt(Price.fromPriceIndex(marketBasis, priceIndex));
            }
        }

        Price newPrice = Price.fromPriceIndex(marketBasis, priceIndex);

        allocatedFlow = originalBid.getDemandAt(newPrice);

        return newPrice;
    }

    /**
     * @return the difference between the measured flow and the allocation for the cluster. If either the measurement or
     *         the allocation is not available, this method will return Double.NaN.
     */
    protected double getUncontrolledFlow() {
        return measuredFlow - allocatedFlow;
    }

    /**
     * Clip a bid such that no power value in the bid exceeds the ceiling or the floor. Any value in the resulting bid
     * will have resulted from the given bid (i.e. no new power level values will have been introduced).
     *
     * @param bid
     *            The bid to clip.
     * @return The clipped bid.
     */
    private Bid clip(final Bid bid) {
        double[] demand = bid.getDemand();

        // find start of unclipped region
        int start = findFirstIndexOfUnclippedRegion(demand, ceiling);

        // if there is no unclipped region we use the last (lowest value)
        if (start == -1) {
            Arrays.fill(demand, demand[demand.length - 1]);
        } else {
            // replace part above ceiling with first point in unclipped region
            double firstUnclippedPoint = demand[start];
            for (int i = 0; i < start; i++) {
                demand[i] = firstUnclippedPoint;
            }

            int end = findLastIndexOfUnclippedRegion(demand, floor);

            if (end == -1) {
                // if there is no unclipped region we use the first (highest value)
                Arrays.fill(demand, demand[0]);
            } else {
                // replace part below floor with last point in unclipped region
                double lastUnclippedPoint = demand[end];
                for (int i = end + 1; i < demand.length; i++) {
                    demand[i] = lastUnclippedPoint;
                }
            }
        }

        return new Bid(bid.getMarketBasis(), demand);
    }

    /**
     * Finds the first index in a demand function for which the allocation doesn't exceed the given ceiling. Starting at
     * the lowest price (index), the first index of the region which won't be clipped is the first value in the demand
     * function which is lower than or equal to the ceiling.
     *
     * @param demandFunction
     *            The demand function as an array of power flow values, where positive flow is demand.
     * @param floor
     *            The ceiling which defines the maximum value the unclipped region has.
     * @return The first index of the unclipped region or -1 if there is no region which isn't below the ceiling.
     */
    private int findFirstIndexOfUnclippedRegion(final double[] demandFunction,
                                                final double ceiling) {
        for (int i = 0; i < demandFunction.length; i++) {
            if (demandFunction[i] <= ceiling) {
                return i;
            }
        }

        return -1;
    }

    /**
     * Finds the first index in a demand function for which the allocation doesn't exceed the given floor; the last
     * index of the region which won't be clipped is the last value in the demand function which is greater than or
     * equal to the ceiling.
     *
     * @param demandFunction
     *            The demand function as an array of power flow values, where positive flow is demand.
     * @param floor
     *            The floor which defines the minimum value the unclipped region has.
     * @return The last index of the unclipped region or -1 if there is no region which isn't above the floor.
     */
    private int findLastIndexOfUnclippedRegion(final double[] demandFunction,
                                               final double floor) {
        for (int i = demandFunction.length - 1; i >= 0; i--) {
            if (demandFunction[i] >= floor) {
                return i;
            }
        }

        return -1;
    }

    @Override
    public void setMeasuredFlow(Measurable<Power> measuredFlow) {
        this.measuredFlow = measuredFlow.doubleValue(SI.WATT);
    }
}
