package net.powermatcher.core.auctioneer;

import java.util.Map;

import org.osgi.service.component.annotations.Activate;
import org.osgi.service.component.annotations.Component;
import org.osgi.service.component.annotations.Deactivate;
import org.osgi.service.metatype.annotations.AttributeDefinition;
import org.osgi.service.metatype.annotations.AttributeType;
import org.osgi.service.metatype.annotations.Designate;
import org.osgi.service.metatype.annotations.ObjectClassDefinition;

import net.powermatcher.api.MatcherEndpoint;
import net.powermatcher.api.data.Bid;
import net.powermatcher.api.data.MarketBasis;
import net.powermatcher.api.data.Price;
import net.powermatcher.api.monitoring.ObservableAgent;
import net.powermatcher.core.BaseMatcherEndpoint;
import net.powermatcher.core.bidcache.AggregatedBid;
import net.powermatcher.core.concentrator.Concentrator;

/**
 * <p>
 * This class represents an {@link Auctioneer} component which will receive all {@link Bid} of other agents as a single
 * {@link Bid} or as an aggregate {@link Bid} via one or more {@link Concentrator}.
 * </p>
 *
 * It is responsible for defining and sending the {@link MarketBasis} and calculating the equilibrium based on the
 * {@link Bid} from the different agents in the topology. This equilibrium is communicated to the agents down the
 * hierarchy in the form of price update messages.
 *
 * @author FAN
 * @version 2.1
 */
@Component(immediate = true,
           service = { ObservableAgent.class, MatcherEndpoint.class })
@Designate(ocd = Auctioneer.Config.class, factory = true)
public class Auctioneer
    extends BaseMatcherEndpoint
    implements MatcherEndpoint {

    @ObjectClassDefinition
    public @interface Config {
        @AttributeDefinition
        String agentId() default "auctioneer";

        @AttributeDefinition
        String clusterId() default "DefaultCluster";

        @AttributeDefinition(description = "Commodity of the market basis")
        String commodity() default "electricity";

        @AttributeDefinition(description = "Currency of the market basis")
        String currency() default "EUR";

        @AttributeDefinition(type = AttributeType.INTEGER,
                             description = "Number of price steps in the market basis")
        int priceSteps() default 100;

        @AttributeDefinition(type = AttributeType.DOUBLE,
                             description = "Minimum price of the market basis")
        double minimumPrice() default 0.0;

        @AttributeDefinition(type = AttributeType.DOUBLE,
                             description = "Maximum price of the market basis")
        double maximumPrice() default 1.0;

        @AttributeDefinition(type = AttributeType.LONG,
                             description = "Mimimum time between two PriceUpdates generated by the Auctioneer in milliseconds")
        long minTimeBetweenPriceUpdates() default 1000L;
    }

    /**
     * OSGi calls this method to activate a managed service.
     *
     * @param properties
     *            the configuration properties
     */
    @Activate
    public void activate(final Map<String, ?> properties) {
        super.init((String) properties.get("agentId"));
        String clusterId = (String) properties.get("clusterId");
        String commodity = (String) properties.get("commodity");
        String currency = (String) properties.get("currency");
        int priceSteps = ((Number) properties.get("priceSteps")).intValue();
        double minimumPrice = ((Number) properties.get("minimumPrice")).doubleValue();
        double maximumPrice = ((Number) properties.get("maximumPrice")).doubleValue();
        long minTimeBetweenPriceUpdates = ((Number) properties.get("minTimeBetweenPriceUpdates")).longValue();

        MarketBasis marketBasis = new MarketBasis(commodity,
                                                  currency,
                                                  priceSteps,
                                                  minimumPrice,
                                                  maximumPrice);

        configure(marketBasis, clusterId, minTimeBetweenPriceUpdates);
    }

    /**
     * OSGi calls this method to deactivate a managed service.
     */
    @Deactivate
    public void deactivate() {
        unconfigure();
    }

    /**
     * This method determines the {@link Price}, given the current aggregated {@link Bid} and sends it to all sessions
     * by calling the {@link #publishPrice(Price, AggregatedBid)} method.
     *
     * @param aggregatedBid
     *            the aggregated {@link Bid} used to determine the {@link Price}
     */
    @Override
    protected void performUpdate(AggregatedBid aggregatedBid) {
        Price price = aggregatedBid.calculateIntersection(0);
        publishPrice(price, aggregatedBid);
    }
}
