package net.powermatcher.remote.websockets.client;

import java.io.IOException;
import java.net.URI;
import java.net.URISyntaxException;
import java.util.concurrent.Future;
import java.util.concurrent.ScheduledFuture;
import java.util.concurrent.ScheduledThreadPoolExecutor;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicInteger;

import org.eclipse.jetty.util.ssl.SslContextFactory;
import org.eclipse.jetty.websocket.api.CloseStatus;
import org.eclipse.jetty.websocket.api.Session;
import org.eclipse.jetty.websocket.api.WebSocketException;
import org.eclipse.jetty.websocket.api.annotations.OnWebSocketClose;
import org.eclipse.jetty.websocket.api.annotations.OnWebSocketMessage;
import org.eclipse.jetty.websocket.api.annotations.WebSocket;
import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;
import org.eclipse.jetty.websocket.client.WebSocketClient;
import org.osgi.framework.BundleContext;
import org.osgi.framework.ServiceRegistration;
import org.osgi.service.component.annotations.Activate;
import org.osgi.service.component.annotations.Component;
import org.osgi.service.component.annotations.Deactivate;
import org.osgi.service.metatype.annotations.AttributeDefinition;
import org.osgi.service.metatype.annotations.AttributeType;
import org.osgi.service.metatype.annotations.Designate;
import org.osgi.service.metatype.annotations.ObjectClassDefinition;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.google.gson.JsonSyntaxException;

import net.powermatcher.api.MatcherEndpoint;
import net.powermatcher.api.messages.BidUpdate;
import net.powermatcher.api.messages.PriceUpdate;
import net.powermatcher.api.monitoring.ObservableAgent;
import net.powermatcher.core.BaseMatcherEndpoint;
import net.powermatcher.core.bidcache.AggregatedBid;
import net.powermatcher.core.concentrator.BidHistoryStore;
import net.powermatcher.core.concentrator.SentBidInformation;
import net.powermatcher.remote.websockets.data.ClusterInfoModel;
import net.powermatcher.remote.websockets.data.PmMessage;
import net.powermatcher.remote.websockets.data.PmMessage.PayloadType;
import net.powermatcher.remote.websockets.data.PriceUpdateModel;
import net.powermatcher.remote.websockets.json.ModelMapper;
import net.powermatcher.remote.websockets.json.PmJsonSerializer;

/**
 * WebSocket implementation of an {@link MatcherEndpoint}. Enabled two agents to communicate via WebSockets and JSON
 * over a TCP connection.
 *
 * @author FAN
 * @version 2.1
 */
@WebSocket()
@Component(immediate = true,
           service = { ObservableAgent.class })
@Designate(ocd = WebsocketClient.Config.class, factory = true)
public class WebsocketClient
    extends BaseMatcherEndpoint {

    private static final Logger LOGGER = LoggerFactory.getLogger(WebsocketClient.class);

    @ObjectClassDefinition(description = "Remote client over websockets configuration")
    public @interface Config {
        @AttributeDefinition(description = "The unique identifier of the agent")
        String agentId() default "matcherendpointproxy";

        @AttributeDefinition(description = "The unique identifier of the connection (e.g. username)")
        String connectionId() default "connection1";

        @AttributeDefinition(description = "URL of powermatcher websocket endpoint.")
        String powermatcherUrl() default "ws://localhost:8080/powermatcher/websocket";

        @AttributeDefinition(type = AttributeType.INTEGER,
                             description = "reconnect timeout keeping the connection alive.")
        int reconnectTimeout() default 30;

        @AttributeDefinition(type = AttributeType.INTEGER,
                             description = "connect timeout to wait for remote server to respond.")
        int connectTimeout() default 60;

        @AttributeDefinition(type = AttributeType.LONG,
                             description = "Mimimum time between two BidUpdates generated by the Concentratro in milliseconds")
        long minTimeBetweenBidUpdates() default 1000L;
    }

    private URI powermatcherUrl;

    private Session remoteSession;

    private WebSocketClient client;

    private int reconnectDelay, connectTimeout;

    private long minTimeBetweenBidUpdates;

    private BundleContext bundleContext;

    private ServiceRegistration<MatcherEndpoint> matcherEndpointServiceRegistration;

    private final ScheduledThreadPoolExecutor executorService = new ScheduledThreadPoolExecutor(1);

    private ScheduledFuture<?> scheduledFuture;

    private final AtomicInteger bidNumberGenerator = new AtomicInteger();

    private final BidHistoryStore sentBids = new BidHistoryStore();

    /**
     * OSGi calls this method to activate a managed service.
     *
     * @param properties
     *            the configuration properties
     * @throws Exception
     */
    @Activate
    public void activate(BundleContext bundleContext, final Config config) throws Exception {
        // Read configuration properties
        init(config.agentId());

        try {
            powermatcherUrl = new URI(config.powermatcherUrl() + "?agentId="
                                      + getAgentId()
                                      + "&connectionId="
                                      + config.connectionId());
        } catch (URISyntaxException e) {
            LOGGER.error("Malformed URL for powermatcher websocket endpoint. Reason {}", e);
            return;
        }

        reconnectDelay = config.reconnectTimeout();
        connectTimeout = config.connectTimeout();
        minTimeBetweenBidUpdates = config.minTimeBetweenBidUpdates();

        this.bundleContext = bundleContext;

        SslContextFactory ssl = new SslContextFactory();
        client = new WebSocketClient(ssl);
        try {
            client.start();
        } catch (Exception e) {
            LOGGER.warn("Could not start websocket client: " + e.getMessage(), e);
            throw e;
        }

        Runnable reconnectJob = new Runnable() {
            @Override
            public void run() {
                connectRemote();
            }
        };
        scheduledFuture = executorService.scheduleAtFixedRate(reconnectJob,
                                                              1,
                                                              reconnectDelay,
                                                              TimeUnit.SECONDS);
    }

    /**
     * OSGi calls this method to deactivate a managed service.
     */
    @Deactivate
    public void deactivate() {
        try {
            client.stop();
        } catch (Exception e) {
            LOGGER.warn("Could not stop websocket client: " + e.getMessage(), e);
        }
        unregisterMatcherEndpoint();
        scheduledFuture.cancel(true);
        disconnectRemote();
    }

    /**
     * {@inheritDoc}
     *
     * This specific implementation opens a websocket.
     */
    private void connectRemote() {
        if (!isRemoteConnected()) {
            // Try to setup a new websocket connection.
            try {
                ClientUpgradeRequest request = new ClientUpgradeRequest();
                Future<Session> connectFuture = client.connect(this, powermatcherUrl, request);
                LOGGER.info("Connecting to : {}", request.getRequestURI());

                // Wait configurable time for remote to respond
                remoteSession = connectFuture.get(connectTimeout, TimeUnit.SECONDS);
            } catch (Exception e) {
                LOGGER.error("Unable to connect to remote agent. Reason {}", e);
                remoteSession = null;
            }
        }
    }

    /**
     * {@inheritDoc}
     *
     * This specific implementation closes the open websocket.
     */
    private void disconnectRemote() {
        // Terminate remote session (if any)
        if (isRemoteConnected()) {
            remoteSession.close(new CloseStatus(0, "Normal disconnect"));
        }
    }

    /**
     * Determines whether the Websocket is connected.
     *
     * @return true when connected, false otherwise
     */
    public boolean isRemoteConnected() {
        return remoteSession != null && remoteSession.isOpen();
    }

    /**
     *
     * @param statusCode
     * @param reason
     */
    @OnWebSocketClose
    public void onDisconnect(int statusCode, String reason) {
        LOGGER.info("Connection closed: {} - {}", statusCode, reason);
        remoteSession = null;
        unconfigure();
        unregisterMatcherEndpoint();
    }

    /**
     * Handle Websocket receive message
     *
     * @param message
     *            the message received via Websockets
     */
    @OnWebSocketMessage
    public void onMessage(String message) {
        LOGGER.debug("Received message from remote agent {}", message);

        try {
            // Decode the JSON data
            PmJsonSerializer serializer = new PmJsonSerializer();
            PmMessage pmMessage = serializer.deserialize(message);

            if (!getStatus().isConnected()) {
                if (pmMessage.getPayloadType() == PayloadType.CLUSTERINFO) {
                    // Sync marketbasis and clusterid with local session, for new
                    // connections
                    ClusterInfoModel clusterInfo = (ClusterInfoModel) pmMessage.getPayload();
                    configure(ModelMapper.convertMarketBasis(clusterInfo.getMarketBasis()),
                              clusterInfo.getClusterId(),
                              minTimeBetweenBidUpdates);

                    // Register the MatcherEndpoint with the OSGI runtime, to make it available for connections
                    registerMatcherEndpoint();
                } else {
                    LOGGER.warn("Got unexpected message type [{}], expected CLUSTERINFO", pmMessage.getPayloadType());
                }
            } else {
                // Handle specific message
                if (pmMessage.getPayloadType() == PayloadType.PRICE_UPDATE) {
                    // Relay price update to local agents
                    PriceUpdate priceUpdate = ModelMapper.mapPriceUpdate((PriceUpdateModel) pmMessage.getPayload());

                    SentBidInformation info = sentBids.retrieveAggregatedBid(priceUpdate.getBidNumber());
                    publishPrice(priceUpdate.getPrice(), info.getOriginalBid());
                } else {
                    LOGGER.warn("Got unexpected message type [{}], expected PRICE_UPDATE", pmMessage.getPayloadType());
                }
            }
        } catch (JsonSyntaxException e) {
            LOGGER.warn("Unable to understand message from remote agent: {}", message);
        }
    }

    /**
     * {@inheritDoc}
     */
    @Override
    protected void performUpdate(AggregatedBid aggregatedBid) {
        synchronized (sentBids) {
            BidUpdate bidUpdate = publishBid(aggregatedBid);
            if (bidUpdate != null) {
                sentBids.saveBid(aggregatedBid, bidUpdate);
            }
        }
    }

    /**
     * Publish an AggregatedBid via Websockets to {@link AgentProxy}
     *
     * @param newBid
     *            the bid to publish
     * @return bidupdate containing bidnumber and published bid
     */
    private BidUpdate publishBid(AggregatedBid newBid) {
        BidUpdate update = new BidUpdate(newBid, bidNumberGenerator.incrementAndGet());
        PmJsonSerializer serializer = new PmJsonSerializer();
        String message = serializer.serializeBidUpdate(update);

        if (isRemoteConnected()) {
            try {
                remoteSession.getRemote().sendString(message);
                LOGGER.debug("Sent bid update to server {}", update);
                return update;
            } catch (IOException | WebSocketException | NullPointerException e) {
                LOGGER.error("Unable to send new bid to remote agent. Reason {}", e);
                return null;
            }
        } else {
            LOGGER.info("Can not send new bid, not connected (remote.isOpen={})",
                        remoteSession == null ? false : remoteSession.isOpen());
            return null;
        }
    }

    /**
     * Register the MatcherEndpoint service
     */
    private void registerMatcherEndpoint() {
        if (matcherEndpointServiceRegistration == null) {
            matcherEndpointServiceRegistration = bundleContext.registerService(MatcherEndpoint.class, this, null);
        }
    }

    /**
     * Unregister the MatcherEndpoint service
     */
    private void unregisterMatcherEndpoint() {
        if (matcherEndpointServiceRegistration != null) {
            matcherEndpointServiceRegistration.unregister();
            matcherEndpointServiceRegistration = null;
        }
    }
}
